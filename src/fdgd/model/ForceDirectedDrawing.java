package fdgd.model;

/**
 * Models force-directed graph drawing (FDGD) onto arbitrary graphs.
 * <p>
 * This class associates each node the has been generated by {@link NetworkBuilder} with a location (x,y) in a coordinate space.
 * The FDGD is modeled in the following way (Eades, Peter (1984), "A Heuristic for Graph Drawing", Congressus Numerantium 42 (11): 149–160.):
 * <li>
 * Initially each node is given a random spawn location in the drawing area.
 * <li>
 * At each discrete time step every pair of connected nodes is affected by a spring like force c_1*log(d/c2).
 * <li>
 * A repulsive force c_3/d^2 affects each pair of nodes.
 * <li>
 * c_1 scales the "strength"and c_2 the lengthwise scale of the spring. c_3 scales the repulsion force. A fourth parameter c_4 is used as a length unit by which the forces are updated in each time step.
 * <li>
 * Eventually the model will converge at least into a local minimum.
 * @author Andre Schuelein
 */
public class ForceDirectedDrawing extends NetworkBuilder {

	double[][] nodeLocations;	//contains the coordinates (x,y) of each node
	double[][] totalForce; 		//contains the force vector the affects each node

	double c1=1;				// spring force 	c1*Math.log(distance/c2);
	double c2=1;				// spring scale
	double c3=5000;				// repulsion scale 	c3/Math.pow(distance, 2);
	double c4=1; 				// animation speed

	double stabilizer1=1;		//to avoid complications when nodes randomly spawn on top of each other
	double stabilizer2=1;		//to avoid complications when nodes randomly spawn on top of each other


	/**
	 * @return the c1
	 */
	public double getC1() {
		return c1;
	}

	/**
	 * @param c1 the c1 to set
	 */
	public void setC1(double c1) {
		this.c1 = c1;
	}

	/**
	 * @return the c2
	 */
	public double getC2() {
		return c2;
	}

	/**
	 * @param c2 the c2 to set
	 */
	public void setC2(double c2) {
		this.c2 = c2;
	}

	/**
	 * @return the c3
	 */
	public double getC3() {
		return c3;
	}

	/**
	 * @param c3 the c3 to set
	 */
	public void setC3(double c3) {
		this.c3 = c3;
	}

	/**
	 * @return the c4
	 */
	public double getC4() {
		return c4;
	}

	/**
	 * @param c4 the c4 to set
	 */
	public void setC4(double c4) {
		this.c4 = c4;
	}

	/**
	 * Constructor: calls the super class constructor {@link NetworkBuilder#NetworkBuilder(int)} and initializes location and force for every node.
	 * @param numberOfNodes
	 */
	public ForceDirectedDrawing(int numberOfNodes) {
		super(numberOfNodes);
		nodeLocations = new double [numON][2];
		totalForce = new double [numON][2];

	}

	/**
	 * Sets all forces to 0.
	 */
	public void initForces(){
		for (int i = 0; i < numON; i++) {
			totalForce[i][0]=0;
			totalForce[i][1]=0;
		}
	}

	/**
	 * Generates initial spawn locations for all nodes with an area constrained by the areas boundaries and the padding.
	 * @param xBoundary x boundary of the drawing area in the model space
	 * @param yBoundary y boundary of the drawing area in the model space
	 * @param xPadding
	 * @param yPadding
	 */
	public void generateInitialSpawns(double xBoundary, double yBoundary, double xPadding, double yPadding){
		for (int i = 0; i < numON; i++) {
			nodeLocations[i][0]=Math.random()*(Math.pow(numON,.3)*xBoundary-2*xPadding)+xPadding;
			nodeLocations[i][1]=Math.random()*(Math.pow(numON,.3)*yBoundary-2*yPadding)+yPadding;		
		}

	}

	/**
	 * Sets the nodes new location.
	 * @param node ID of the node
	 * @param x new x coordinate
	 * @param y new y coordinate
	 */
	public void setNodeLocation(int node, double x, double y){
		nodeLocations[node][0]=x;
		nodeLocations[node][1]=y;
	}

	public double getNodeX(int node){
		return nodeLocations[node][0];
	}

	public double getNodeY(int node){
		return nodeLocations[node][1];
	}

	/**
	 * Computes the forces the are applied to every node by looping of all pais of nodes.
	 */
	public void computeForces(){
		for (int i = 0; i < numON; i++) {
			// loop over all node pairs
			for (int j = 0; j < numON; j++) {
				if (i!=j) {
					if (this.getEdge(i, j)) {
						// if connected
						totalForce[i][0]=totalForce[i][0]+repellingForce(i, j)[0]+attractiveForce(i, j)[0];
						totalForce[i][1]=totalForce[i][1]+repellingForce(i, j)[1]+attractiveForce(i, j)[1];
					} else {
						// if not connected
						totalForce[i][0]=totalForce[i][0]+repellingForce(i, j)[0];
						totalForce[i][1]=totalForce[i][1]+repellingForce(i, j)[1];
					}
				}
			}	
		}
	}

	/**
	 * Updates all forces.
	 * @param ignoreNode ID of the node that should not be affected by any forces because it is being dragged by the user for example.
	 */
	public void applyForce(int ignoreNode){
		for (int i = 0; i < numON; i++) {
			if(i!=ignoreNode){
				nodeLocations[i][0]=nodeLocations[i][0]+c4*totalForce[i][0];
				nodeLocations[i][1]=nodeLocations[i][1]+c4*totalForce[i][1];
			}
		}
	}

	/**
	 * Computes the connecting vector between node1 and node2.
	 * @param node1 ID of the first node
	 * @param node2 ID of the second node
	 * @return the connecting vector between node1 and node2
	 */
	public double[] computeVector(int node1, int node2){
		double[] vec=
			{this.getNodeX(node2)-this.getNodeX(node1),
				this.getNodeY(node2)-this.getNodeY(node1)};
		return vec;
	}

	/**
	 * Computes the normalized vector to a vector given by x and y.
	 * @param x coordinate of the vector
	 * @param y	coordinate of the vector
	 * @return normalized vector
	 */
	public double[] normalizeVector(double x, double y){
		double length=Math.sqrt(Math.pow(Math.abs(x),2)+Math.pow(Math.abs(y),2));
		double[] vec={x/length,y/length};
		return vec;
	}

	/**
	 * Computes the vector of the attractive force between two node.
	 * @param from ID of the first node
	 * @param to ID of the second node
	 * @return force vector
	 */
	public double[] attractiveForce(int from, int to){
		double [] vec;
		double distance=getDistance(from, to);
		vec=computeVector(from, to);//*distance;
		vec=normalizeVector(vec[0], vec[1]);
		double factor = attractiveFunction(distance);
		vec[0]=vec[0]*factor;
		vec[1]=vec[1]*factor;
		return vec;
	}

	/**
	 * Computes the value of the scalar attractive force function based on the given distance of two nodes.
	 * @param distance the distance between the two nodes
	 * @return attractive force
	 */
	private double attractiveFunction(double distance) {
		if (distance<stabilizer1){
			distance=stabilizer1;
		}
		return c1*Math.log(distance/c2)*(1/(stabilizer2*numON));
	}

	/**
	 * Computes the vector of the repelling force between two node.
	 * @param from ID of the first node
	 * @param to ID of the second node
	 * @return force vector
	 */
	public double[] repellingForce(int from, int to){
		double [] vec;
		double distance=getDistance(from, to);
		vec=computeVector(from, to);//*distance;
		vec=normalizeVector(vec[0], vec[1]);
		double factor = -repellingFunction(distance);
		vec[0]=vec[0]*factor;
		vec[1]=vec[1]*factor;
		return vec;
	}

	/**
	 * Computes the value of the scalar repelling force function based on the given distance of two nodes.
	 * @param distance the distance between the two nodes
	 * @return attractive force
	 */
	private double repellingFunction(double distance) {
		if (distance<stabilizer1){
			distance=stabilizer1;
			//System.out.println("stabilized");
		}
		return c3/Math.pow(distance, 2);
	}

	/**
	 * Computes the euclidean distance between two given nodes.
	 * @param node1 ID for the first node
	 * @param node2 ID of the second node
	 * @return euclidean distance between the nodes
	 */
	public double getDistance(int node1, int node2){
		return Math.sqrt(Math.pow(Math.abs(this.getNodeX(node1)-this.getNodeX(node2)),2)
				+Math.pow(Math.abs(this.getNodeY(node1)-this.getNodeY(node2)),2));
	}

	/**
	 * Initiates the simulation of a single step
	 * @param ignoreNode ignoreNode ID of the node that should not be affected by any forces because it is being dragged by the user for example.
	 */
	public void simulateSingleStep(int ignoreNode){
		initForces();
		computeForces();
		applyForce(ignoreNode);
	}

	/**
	 * Computes a box around the graph that exactly contains it.
	 * @return xMin,xMax,yMin,yMax (upper left and lower right corners of the box)
	 */
	public double[] getBoundaries(){
		double xMin, xMax, yMin, yMax;
		xMin=getNodeX(0);
		xMax=getNodeX(0);
		yMin=getNodeY(0);
		yMax=getNodeY(0);
		for (int i = 1; i < numON; i++) {
			if (getNodeX(i)<xMin) {
				xMin=getNodeX(i);
			}
			if (getNodeX(i)>xMax) {
				xMax=getNodeX(i);
			}
			if (getNodeY(i)<yMin) {
				yMin=getNodeY(i);
			}
			if (getNodeY(i)>yMax) {
				yMax=getNodeY(i);
			}
		}
		double [] vec={xMin,xMax,yMin,yMax};
		return vec;
	}

}
